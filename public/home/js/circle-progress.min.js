/**
 * jquery-circle-progress - jQuery Plugin to draw animated circular progress bars:
 * {@link http://kottenator.github.io/jquery-circle-progress/}
 *
 * @author Rostyslav Bryzgunov <kottenator@gmail.com>
 * @version 1.2.2
 * @licence MIT
 * @preserve
 */
!(function (i) { if (typeof define === 'function' && define.amd)define(['jquery'], i); else if (typeof module === 'object' && module.exports) { let t = require('jquery'); i(t), module.exports = t } else i(jQuery) }(function (i) { function t (i) { this.init(i) }t.prototype = { value: 0, size: 180, startAngle: -Math.PI, thickness: 'auto', fill: { color: '#8e989f' }, emptyFill: 'rgba(50, 119, 247, 0.2)', animation: { duration: 1200, easing: 'circleProgressEasing' }, animationStartValue: 0, reverse: !1, lineCap: 'butt', insertMode: 'prepend', constructor: t, el: null, canvas: null, ctx: null, radius: 0, arcFill: null, lastFrameValue: 0, init: function (t) { i.extend(this, t), this.radius = this.size / 2, this.initWidget(), this.initFill(), this.draw(), this.el.trigger('circle-inited') }, initWidget: function () { this.canvas || (this.canvas = i('<canvas>')[this.insertMode == 'prepend' ? 'prependTo' : 'appendTo'](this.el)[0]); let t = this.canvas; if (t.width = this.size, t.height = this.size, this.ctx = t.getContext('2d'), window.devicePixelRatio > 1) { let e = window.devicePixelRatio; t.style.width = t.style.height = this.size + 'px', t.width = t.height = this.size * e, this.ctx.scale(e, e) } }, initFill: function () { function t () { let t = i('<canvas>')[0]; t.width = e.size, t.height = e.size, t.getContext('2d').drawImage(g, 0, 0, r, r), e.arcFill = e.ctx.createPattern(t, 'no-repeat'), e.drawFrame(e.lastFrameValue) } var e = this; let a = this.fill; let n = this.ctx; var r = this.size; if (!a) throw Error('The fill is not specified!'); if (typeof a === 'string' && (a = { color: a }), a.color && (this.arcFill = a.color), a.gradient) { let s = a.gradient; if (s.length == 1) this.arcFill = s[0]; else if (s.length > 1) { for (var l = a.gradientAngle || 0, o = a.gradientDirection || [r / 2 * (1 - Math.cos(l)), r / 2 * (1 + Math.sin(l)), r / 2 * (1 + Math.cos(l)), r / 2 * (1 - Math.sin(l))], h = n.createLinearGradient.apply(n, o), c = 0; c < s.length; c++) { let d = s[c]; let u = c / (s.length - 1); i.isArray(d) && (u = d[1], d = d[0]), h.addColorStop(u, d) } this.arcFill = h } } if (a.image) { var g; a.image instanceof Image ? g = a.image : (g = new Image(), g.src = a.image), g.complete ? t() : g.onload = t } }, draw: function () { this.animation ? this.drawAnimated(this.value) : this.drawFrame(this.value) }, drawFrame: function (i) { this.lastFrameValue = i, this.ctx.clearRect(0, 0, this.size, this.size), this.drawEmptyArc(i), this.drawArc(i) }, drawArc: function (i) { if (i !== 0) { let t = this.ctx; let e = this.radius; let a = this.getThickness(); let n = this.startAngle; t.save(), t.beginPath(), this.reverse ? t.arc(e, e, e - a / 2, n - 2 * Math.PI * i, n) : t.arc(e, e, e - a / 2, n, n + 2 * Math.PI * i), t.lineWidth = a, t.lineCap = this.lineCap, t.strokeStyle = this.arcFill, t.stroke(), t.restore() } }, drawEmptyArc: function (i) { let t = this.ctx; let e = this.radius; let a = this.getThickness(); let n = this.startAngle; i < 1 && (t.save(), t.beginPath(), i <= 0 ? t.arc(e, e, e - a / 2, 0, 2 * Math.PI) : this.reverse ? t.arc(e, e, e - a / 2, n, n - 2 * Math.PI * i) : t.arc(e, e, e - a / 2, n + 2 * Math.PI * i, n), t.lineWidth = a, t.strokeStyle = this.emptyFill, t.stroke(), t.restore()) }, drawAnimated: function (t) { let e = this; let a = this.el; let n = i(this.canvas); n.stop(!0, !1), a.trigger('circle-animation-start'), n.css({ animationProgress: 0 }).animate({ animationProgress: 1 }, i.extend({}, this.animation, { step: function (i) { let n = e.animationStartValue * (1 - i) + t * i; e.drawFrame(n), a.trigger('circle-animation-progress', [i, n]) } })).promise().always(function () { a.trigger('circle-animation-end') }) }, getThickness: function () { return i.isNumeric(this.thickness) ? this.thickness : this.size / 14 }, getValue: function () { return this.value }, setValue: function (i) { this.animation && (this.animationStartValue = this.lastFrameValue), this.value = i, this.draw() } }, i.circleProgress = { defaults: t.prototype }, i.easing.circleProgressEasing = function (i) { return i < 0.5 ? (i = 2 * i, 0.5 * i * i * i) : (i = 2 - 2 * i, 1 - 0.5 * i * i * i) }, i.fn.circleProgress = function (e, a) { let n = 'circle-progress'; let r = this.data(n); if (e == 'widget') { if (!r) throw Error('Calling "widget" method on not initialized instance is forbidden'); return r.canvas } if (e == 'value') { if (!r) throw Error('Calling "value" method on not initialized instance is forbidden'); if (typeof a === 'undefined') return r.getValue(); let s = arguments[1]; return this.each(function () { i(this).data(n).setValue(s) }) } return this.each(function () { let a = i(this); let r = a.data(n); let s = i.isPlainObject(e) ? e : {}; if (r)r.init(s); else { let l = i.extend({}, a.data()); typeof l.fill === 'string' && (l.fill = JSON.parse(l.fill)), typeof l.animation === 'string' && (l.animation = JSON.parse(l.animation)), s = i.extend(l, s), s.el = a, r = new t(s), a.data(n, r) } }) } }))
!(function (i) { if (typeof define === 'function' && define.amd)define(['jquery'], i); else if (typeof module === 'object' && module.exports) { let t = require('jquery'); i(t), module.exports = t } else i(jQuery) }(function (i) { function t (i) { this.init(i) }t.prototype = { value: 0, size: 180, startAngle: -Math.PI, thickness: 'auto', fill: { color: '#8e989f' }, emptyFill: 'rgba(50, 119, 247, 0.2)', animation: { duration: 1200, easing: 'circleProgressEasing' }, animationStartValue: 0, reverse: !1, lineCap: 'butt', insertMode: 'prepend', constructor: t, el: null, canvas: null, ctx: null, radius: 0, arcFill: null, lastFrameValue: 0, init: function (t) { i.extend(this, t), this.radius = this.size / 2, this.initWidget(), this.initFill(), this.draw(), this.el.trigger('circle-inited') }, initWidget: function () { this.canvas || (this.canvas = i('<canvas>')[this.insertMode == 'prepend' ? 'prependTo' : 'appendTo'](this.el)[0]); let t = this.canvas; if (t.width = this.size, t.height = this.size, this.ctx = t.getContext('2d'), window.devicePixelRatio > 1) { let e = window.devicePixelRatio; t.style.width = t.style.height = this.size + 'px', t.width = t.height = this.size * e, this.ctx.scale(e, e) } }, initFill: function () { function t () { let t = i('<canvas>')[0]; t.width = e.size, t.height = e.size, t.getContext('2d').drawImage(g, 0, 0, r, r), e.arcFill = e.ctx.createPattern(t, 'no-repeat'), e.drawFrame(e.lastFrameValue) } var e = this; let a = this.fill; let n = this.ctx; var r = this.size; if (!a) throw Error('The fill is not specified!'); if (typeof a === 'string' && (a = { color: a }), a.color && (this.arcFill = a.color), a.gradient) { let s = a.gradient; if (s.length == 1) this.arcFill = s[0]; else if (s.length > 1) { for (var l = a.gradientAngle || 0, o = a.gradientDirection || [r / 2 * (1 - Math.cos(l)), r / 2 * (1 + Math.sin(l)), r / 2 * (1 + Math.cos(l)), r / 2 * (1 - Math.sin(l))], h = n.createLinearGradient.apply(n, o), c = 0; c < s.length; c++) { let d = s[c]; let u = c / (s.length - 1); i.isArray(d) && (u = d[1], d = d[0]), h.addColorStop(u, d) } this.arcFill = h } } if (a.image) { var g; a.image instanceof Image ? g = a.image : (g = new Image(), g.src = a.image), g.complete ? t() : g.onload = t } }, draw: function () { this.animation ? this.drawAnimated(this.value) : this.drawFrame(this.value) }, drawFrame: function (i) { this.lastFrameValue = i, this.ctx.clearRect(0, 0, this.size, this.size), this.drawEmptyArc(i), this.drawArc(i) }, drawArc: function (i) { if (i !== 0) { let t = this.ctx; let e = this.radius; let a = this.getThickness(); let n = this.startAngle; t.save(), t.beginPath(), this.reverse ? t.arc(e, e, e - a / 2, n - 2 * Math.PI * i, n) : t.arc(e, e, e - a / 2, n, n + 2 * Math.PI * i), t.lineWidth = a, t.lineCap = this.lineCap, t.strokeStyle = this.arcFill, t.stroke(), t.restore() } }, drawEmptyArc: function (i) { let t = this.ctx; let e = this.radius; let a = this.getThickness(); let n = this.startAngle; i < 1 && (t.save(), t.beginPath(), i <= 0 ? t.arc(e, e, e - a / 2, 0, 2 * Math.PI) : this.reverse ? t.arc(e, e, e - a / 2, n, n - 2 * Math.PI * i) : t.arc(e, e, e - a / 2, n + 2 * Math.PI * i, n), t.lineWidth = a, t.strokeStyle = this.emptyFill, t.stroke(), t.restore()) }, drawAnimated: function (t) { let e = this; let a = this.el; let n = i(this.canvas); n.stop(!0, !1), a.trigger('circle-animation-start'), n.css({ animationProgress: 0 }).animate({ animationProgress: 1 }, i.extend({}, this.animation, { step: function (i) { let n = e.animationStartValue * (1 - i) + t * i; e.drawFrame(n), a.trigger('circle-animation-progress', [i, n]) } })).promise().always(function () { a.trigger('circle-animation-end') }) }, getThickness: function () { return i.isNumeric(this.thickness) ? this.thickness : this.size / 14 }, getValue: function () { return this.value }, setValue: function (i) { this.animation && (this.animationStartValue = this.lastFrameValue), this.value = i, this.draw() } }, i.circleProgress = { defaults: t.prototype }, i.easing.circleProgressEasing = function (i) { return i < 0.5 ? (i = 2 * i, 0.5 * i * i * i) : (i = 2 - 2 * i, 1 - 0.5 * i * i * i) }, i.fn.circleProgress = function (e, a) { let n = 'circle-progress'; let r = this.data(n); if (e == 'widget') { if (!r) throw Error('Calling "widget" method on not initialized instance is forbidden'); return r.canvas } if (e == 'value') { if (!r) throw Error('Calling "value" method on not initialized instance is forbidden'); if (typeof a === 'undefined') return r.getValue(); let s = arguments[1]; return this.each(function () { i(this).data(n).setValue(s) }) } return this.each(function () { let a = i(this); let r = a.data(n); let s = i.isPlainObject(e) ? e : {}; if (r)r.init(s); else { let l = i.extend({}, a.data()); typeof l.fill === 'string' && (l.fill = JSON.parse(l.fill)), typeof l.animation === 'string' && (l.animation = JSON.parse(l.animation)), s = i.extend(l, s), s.el = a, r = new t(s), a.data(n, r) } }) } }))
